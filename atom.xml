<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>刘哈哈的碎碎念</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liuyangzuo.github.io/"/>
  <updated>2018-06-02T09:30:35.844Z</updated>
  <id>http://liuyangzuo.github.io/</id>
  
  <author>
    <name>刘哈哈</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React Overview</title>
    <link href="http://liuyangzuo.github.io/2018/06/02/React%20Overview/"/>
    <id>http://liuyangzuo.github.io/2018/06/02/React Overview/</id>
    <published>2018-06-01T16:00:00.000Z</published>
    <updated>2018-06-02T09:30:35.844Z</updated>
    
    <content type="html"><![CDATA[<p>   第一次接触React的时候是还是15年我在天猫实习时候，毕业之后一直写React有2年的时间了，从0.13版本到现在16.4.0一直在跟进，并且投入大量的精力深入学习，对React疯狂热爱，痴迷，自己对setState, Transaction, Diff过程, Virtual DOM, LifeCycle, Dumb Components, Smart Components, 高阶组件HOC, context, 事件系统SyntheticEvent, React Motion, Redux, React Redux, React Router, React SSR的<strong>实现原理</strong>都有较好的理解，打算写20+篇文章进行总结回顾，用言简意赅的语言表述核心概念和原理，默认你已经学过React或者写过一些React应用，想进一步对提升对React理解，本身写东西也是对我自己温故而知新的过程。</p><p>​   了解React之前，我们讨论一些知识点，基础的概念，对理解React原理有很大的好处。</p><h4 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1 简单的HTML标签</span></div><div class="line"><span class="keyword">const</span> element = &lt;h1 id="hello"&gt;Hello, React!&lt;br/&gt;&lt;/h1&gt;;</div><div class="line"></div><div class="line"><span class="comment">// 2 自定义组件(components)</span></div><div class="line"><span class="keyword">const</span> content = <span class="string">'React'</span>;</div><div class="line"><span class="keyword">const</span> customCompenent = &lt;CustomCompenent&gt;&#123;content&#125;&lt;/CustomCompenent&gt;;</div></pre></td></tr></table></figure><p>上面的代码就是一段JSX表达式(XML-like expression)，JSX里面可以写一些变量，表达式或者一些JS的计算，这里不再赘述。它将被编译成function call，形式如下，这个过程有个叫<code>hyperscript</code>的概念，可以自行查阅一番。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">nodeName, atttibutes, ...children</span>)</span>&#123; <span class="comment">/* ...先不关心h函数的实现 */</span>&#125;;</div><div class="line"><span class="comment">// jsx通过Babel编译后的function call形式，其实h()就是类似React.createElement()</span></div><div class="line"><span class="comment">// 1 简单形式</span></div><div class="line">h(<span class="string">'h1'</span>, &#123;<span class="attr">id</span>: <span class="string">'hello'</span>&#125;, </div><div class="line">  <span class="string">'Hello, React'</span>, </div><div class="line">  h(<span class="string">'br'</span>)</div><div class="line">);</div><div class="line"><span class="comment">// 2 自定义组件形式，CustomCompenent是自定义组件，实际上就是一个function</span></div><div class="line">h(CustomCompenent, <span class="string">'hello react'</span>);</div></pre></td></tr></table></figure><h4 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h4><p>  Virtual DOM是一个被说烂的话题，一句话<code>Virtual DOM就是JavaScript Object</code>。引入Virtual DOM的原因很简单，我们知道DOM操作是耗费性能(这句话总被提起，其实很好发现它是十分耗费性能的,可以写一小段代码来测试DOM增删改查的时间)，React团队的想法简单纯粹，用JavaScript对象来描述表示DOM，框架层面上帮你进行批量的diff，patch过程，统一的机制帮你进行DOM的创建和更新(后面我会写具体实现原理, under the the hood)，节省开销，从而获得性能上的收益（官方也提供了React Pref来查看性能指标）。总之React帮你做了从Virtual DOM到真实DOM的高效映射过程，你无需专注DOM，把关注点放在如何更改state， View = f (state)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// DOM 操作 test</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createNodeFactory</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; num; i ++) &#123;</div><div class="line">   <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">   <span class="keyword">var</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">'text'</span> + i);</div><div class="line">   div.appendChild(text);</div><div class="line">   <span class="built_in">document</span>.body.appendChild(div)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArrayFatory</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> arr = [];</div><div class="line">  <span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num ; i ++)&#123;</div><div class="line">    arr[i] = i;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="keyword">var</span> t1 = <span class="keyword">new</span> <span class="built_in">Date</span>;</div><div class="line">createNodeFactory(<span class="number">100000</span>);    </div><div class="line"><span class="keyword">var</span> t2 = <span class="keyword">new</span> <span class="built_in">Date</span>;</div><div class="line">createArrayFatory(<span class="number">100000</span>);    </div><div class="line"><span class="keyword">var</span> t3= <span class="keyword">new</span> <span class="built_in">Date</span>;</div><div class="line"><span class="built_in">console</span>.log(t2 - t1); <span class="comment">// 210 </span></div><div class="line"><span class="built_in">console</span>.log(t3 - t2); <span class="comment">// 5</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> 这里栗子虽然十分不严谨，还有什么createDocumentFragment，但是其实也是微乎其微的，这个栗子可以说DOM的操作相比单纯的js计算真的很慢。</span></div><div class="line"><span class="comment">*/</span></div></pre></td></tr></table></figure><p>看看Virtual DOM 到底是个什么样子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Virtual DOM 的真实情况基本类似下面这个样子</span></div><div class="line"><span class="keyword">var</span> vdom = &#123;</div><div class="line">   nodeName:<span class="string">'h1'</span>,</div><div class="line">   attributes: &#123; <span class="attr">id</span>:<span class="string">'hello'</span> &#125;,</div><div class="line">   children: [</div><div class="line">     <span class="string">'Hello, React!'</span>,</div><div class="line">     &#123; <span class="attr">nodeName</span>:<span class="string">'br'</span> &#125;</div><div class="line">   ]</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="comment">// 自定义组件</span></div><div class="line"><span class="keyword">var</span> customCompoment = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/*...*/</span>&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> vdom = &#123;</div><div class="line">   nodeName: customCompoment,</div><div class="line">   attributes: &#123;<span class="comment">/*....*/</span>&#125;,</div><div class="line">   children: [</div><div class="line">     <span class="comment">/*xxxxx*/</span></div><div class="line">   ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>   用一个图表示这一个过程。</p><p><img src="https://i.loli.net/2018/06/02/5b126144d9bfe.png" alt="jsx-hyperscript-vdom"></p><h4 id="Virtual-DOM-Factocy"><a href="#Virtual-DOM-Factocy" class="headerlink" title="Virtual DOM Factocy"></a>Virtual DOM Factocy</h4><p>​ 接下来了解一下hyperscript的概念</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">nodeName, attributes, ...children</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123; nodeName, attributes, children &#125;</div><div class="line">  &#125;</div><div class="line"><span class="comment">// 可以根据需要实现你自己的hyperscript方法，react实现了自己的方法叫createElement</span></div></pre></td></tr></table></figure><h4 id="Render"><a href="#Render" class="headerlink" title="Render"></a>Render</h4><p>  前提我们讨论的是同步render的范畴，考虑一下当拥有一个VNode时候，怎么渲染到浏览器。观察VNode的结构，VNode已经告诉我们了名称(tag, componment)，属性，子节点，讨论到子节点瞬间就要想到有递归渲染的反应，尝试写下简单的render函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode</span>) </span>&#123;</div><div class="line">  <span class="comment">/* 我们还要判断一下vnode类型，</span></div><div class="line"><span class="comment">     case 1 文本</span></div><div class="line"><span class="comment">     case 2 元素tag</span></div><div class="line"><span class="comment">     case 3 自定义组件，先忽略吧</span></div><div class="line"><span class="comment">  */</span></div><div class="line">   <span class="keyword">if</span>(<span class="keyword">typeof</span> vnode === <span class="string">'string'</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="built_in">document</span>.createTextNode(vnode);</div><div class="line">   &#125;</div><div class="line">    </div><div class="line">   <span class="keyword">let</span> node = <span class="built_in">document</span>.createElement(vnode.nodeName);</div><div class="line"></div><div class="line">   <span class="keyword">for</span> (attribute <span class="keyword">in</span> vnode.attributes) &#123;</div><div class="line">      node.setAttribute(attribute, vnode.attributes[attribute]);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 矫正</span></div><div class="line">   vnode.children = vnode.children || [];</div><div class="line"></div><div class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vnode.children.length; i++ )&#123;</div><div class="line">       node.appendChild(render(vnode.children[i]));</div><div class="line">   &#125;</div><div class="line">    </div><div class="line">   <span class="keyword">return</span> node;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="Attributes-or-Properties"><a href="#Attributes-or-Properties" class="headerlink" title="Attributes or Properties"></a>Attributes or Properties</h4><p>  在render小节中我们讨论的基本是首次渲染的情况，也渲染了真实的DOM节点，接下里讨论一下DOM元素的属性。DOM属性可能是重新设置了一个新的，也可能是原有的属性发生了update。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffProps</span>(<span class="params">node, vnode</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> property <span class="keyword">in</span> vnode.attributes) &#123;</div><div class="line">       <span class="keyword">let</span> value = vnode.attributes[property];</div><div class="line">        <span class="keyword">if</span>(property <span class="keyword">in</span> node) &#123;</div><div class="line">            node.property = value;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            node.setAttributes(property, value)</div><div class="line">        &#125;   </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="Diffing"><a href="#Diffing" class="headerlink" title="Diffing"></a>Diffing</h4><p>  再讨论一下diff过程，先看看Virtual DOM , 和使用render函数生成真实的DOM情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Virtual DOM</span></div><div class="line"><span class="keyword">var</span> vdom = &#123;</div><div class="line">    nodeName: <span class="string">'div'</span>,</div><div class="line">    attributes: &#123;</div><div class="line">      key: <span class="string">'03'</span>,</div><div class="line">    &#125;,</div><div class="line">    children: [</div><div class="line">      <span class="string">'text node '</span></div><div class="line">    ]</div><div class="line">&#125;</div><div class="line"><span class="comment">// render 之后我们生成的真实DOM</span></div><div class="line"><span class="comment">// Actual DOM</span></div><div class="line">Element(</div><div class="line">   nodeName: <span class="string">'div'</span>,</div><div class="line">    attributes: &#123;</div><div class="line">      getItem(<span class="string">'key'</span>),</div><div class="line">      setItem(<span class="string">'key'</span>, value)</div><div class="line">    &#125;,</div><div class="line">    childNodes: [</div><div class="line">      TextNMode(<span class="string">'text node'</span>)</div><div class="line">    ]</div><div class="line">)</div></pre></td></tr></table></figure><p>​ diff的过程先不展开说，后面介绍，但是可以说diff的思路，diff很明显有一个递归的过程要遍历子节点的情况，diff要查看DOM属性啊，事件监听啊(如果事件是直接绑定元素上,react并不是这样做的)，textNode变化，节点是否删除，是否新增，宗旨是我们可以得到oldVnode和newVnode，找到diif的partial Object 再patch，完成oldActualDOM到newActualDOM的映射更新，diff过程是决定React架性能的最重要影响因素，也是最复杂的地方没有之一，涉及到如何设计，使用什么diff算法，引入了key标记的优化等，大有文章。</p><h4 id="React-Component"><a href="#React-Component" class="headerlink" title="React Component"></a>React Component</h4><p>  了解基础概念之后，开始React话题，先看看ES5/ES6的写法，ECMAScript在发展，React也发展了几年，经历了ES5到ES6的升级，ES6的 Componment带来的一些新的小特性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="keyword">var</span> CartES5 = React.createClass(&#123;</div><div class="line">    getDefaltProps: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">           key1: <span class="string">'value1'</span>,</div><div class="line">           key2: <span class="string">'value2'</span>,</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    </div><div class="line">    getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            key3: <span class="string">'value3'</span>,</div><div class="line">            key4: <span class="string">'value4'</span>,</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    </div><div class="line">    handleClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        </div><div class="line">    &#125;,</div><div class="line">    </div><div class="line">    handleOnChage: <span class="function"><span class="keyword">function</span>(<span class="params">inputIndex, e</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> state = &#123;&#125;;</div><div class="line">        state[<span class="string">'key'</span> + inpuIndex] = e.target.value;</div><div class="line">        <span class="keyword">this</span>.setState(state);</div><div class="line">        </div><div class="line">    &#125;,</div><div class="line">    </div><div class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="keyword">return</span> (&lt;div onClick=&#123;this.handleClick&#125;&gt;</div><div class="line">              &lt;div&gt;Cart Component&lt;/div&gt;</div><div class="line">              &lt;input onChange=&#123;this.handleOnChage&#125;/&gt;</div><div class="line">             &lt;/div&gt;);</div><div class="line">  &#125;,</div><div class="line">    componentWillMount: function() &#123; … &#125;</div><div class="line">&#125;)</div><div class="line">/*</div><div class="line">  ES6 使用Class来定义组件，生命周期componmentWillMount的功能可在constructor完成，</div><div class="line">  事件绑定在constructor中一次性绑定，变量解构, 箭头函数，模版字符串等新的特性可以使用。</div><div class="line">*/</div><div class="line">class CartES6 extends React.Componment &#123;</div><div class="line">    constructor(props)&#123;</div><div class="line">        super(props);</div><div class="line">        this.handleClick = this.handleClick.bind(this);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    static defaultProps = &#123;</div><div class="line">       key1: 'value1',</div><div class="line">       key2: 'value2', </div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    state = &#123;</div><div class="line">      key3: 'value3',</div><div class="line">      key4: 'value4',      </div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    handleClick = (e) =&gt; &#123;        </div><div class="line">        </div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    handleOnChage(inputIndex, e) &#123;</div><div class="line">      this.setState(&#123;[`key$&#123;inputIndex&#125;`]: e.target.value&#125;);</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    render() &#123;</div><div class="line">      // 支持了变量解构析构</div><div class="line">      const &#123; className, ...opts &#125; = this.props;</div><div class="line">      return (&lt;div onClick=&#123;this.handleClick&#125;&gt;</div><div class="line">                &lt;div&gt;Cart Component&lt;/div&gt;</div><div class="line">                &lt;input onChange=&#123;this.handleOnChage&#125;/&gt;</div><div class="line">                &lt;CustomComponmen &#123;...opts&#125;/&gt;              </div><div class="line">              &lt;/div&gt;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="Functional-Component"><a href="#Functional-Component" class="headerlink" title="Functional Component"></a>Functional Component</h4><p>还有一种简单的方式来定义一个组件，就是使用JavaSctipt的函数,这种没有生命周期钩子，纯展示型的组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloReact</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &lt;div&gt;Hello React&lt;/div&gt;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 社区比较推崇这种写法，组件其实分好多种，容器组件，展示型的组件，后面再写出组件的一些分类.</span></div></pre></td></tr></table></figure><h4 id="React-Event"><a href="#React-Event" class="headerlink" title="React Event"></a>React Event</h4><p>​ 大多数人知道React的事件系统是合成事件(SyntheticEvent)，所有的事件使用事件代理到document上，做统一的事件dispatch，自己实现的事件冒泡过程，阻止默认行为，阻止事件冒泡等，另外React团队称是实现的符合规范的处理了各种厂商事件的兼容性问题，但是这里面一个小插曲，我问过的人没有一个回答正确的，就是React实现的onChange事件(PS : 后面我再写SyntheticEvent实现原理)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">  抛开React，聊一聊onChange事件,大多数人都理解错了input标签的onChange事件，onChange事件触发的时机是value值改变，那么什么是value值改变呢，是失去焦点！失去焦点！失去焦点，也就是说，onChange事件的的触发不是时时，时时触发的事件是onInput!时时触发的事件是onInput!时时触发的事件是onInput.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props)&#123;</div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">        <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    handleChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</div><div class="line">        <span class="comment">// 这里的`e`是synthetic event</span></div><div class="line">        <span class="built_in">console</span>.log(e.target.value);</div><div class="line">    &#125;</div><div class="line">    render()&#123;</div><div class="line">        <span class="keyword">return</span> &lt;input onChange=&#123;this.handleChange&#125;/&gt;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">/*</div><div class="line"> 上面的代码运行之后，我发现console是时时的，既然React的事件系统是符合标准的，为何onchange事件表现不一致，我在github issues中找到了DAN的回答，也在stackoverflow找到了答案，这是4 5年前的事情了，也是React团队最开始的一个错误，因为大多数人觉得change事件应该就是时时的，所以React团队在实现时考虑到了习惯，没有完全符合标准。</div><div class="line"> https://stackoverflow.com/questions/38256332/in-react-whats-the-difference-between-onchange-and-oninput</div><div class="line">*/</div></pre></td></tr></table></figure><p>   再来看一看时间事件传递参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zoombie</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    handleOnClick(params, e) &#123;</div><div class="line">       <span class="built_in">console</span>.log(params, e);</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">       <span class="keyword">let</span> params = &#123;<span class="attr">test</span>: <span class="string">'test'</span>&#125;;</div><div class="line">       <span class="keyword">return</span> (&lt;div onClick=&#123;this.handleOnClick.bind(this, params)&#125;&gt;Zoombie&lt;/div&gt;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>   官方文档Handling Events这一小节，说明了一些注意事项，其实大部分人并没有看过吧，<a href="https://reactjs.org/docs/handling-events.html" target="_blank" rel="external">https://reactjs.org/docs/handling-events.html</a></p><h4 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h4><p>  在render函数写bind函数和在constructor中一次bind有什么区别呢？为什么要手动bind？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> 官方文档给出了两个链接</span></div><div class="line"><span class="comment"> 1. how functions work in JavaScript</span></div><div class="line"><span class="comment">  https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/</span></div><div class="line"><span class="comment"> 2.MDN bind function</span></div><div class="line"><span class="comment"> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="comment">// 1.InputComponment组件在constructor函数里面有一句bind相关的, render函数直接就用this.handleChange</span></div><div class="line"><span class="keyword">constructor</span>() &#123;</div><div class="line">  <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 2.也可以不在constructor绑定，直接在render函数里面bind，怎么都是可以的，</span></div><div class="line">render() &#123;</div><div class="line">    <span class="keyword">return</span> &lt;input onChage=&#123;this.handleChange.bind(this)&#125;/&gt;</div><div class="line">&#125;</div><div class="line">// 3.如果使用箭头函数，就可以不用在constructor绑定，这是因为和箭头函数的this有关</div><div class="line">render() &#123;</div><div class="line">   return &lt;button onClick=&#123;(e) =&gt; this.handleClick(e)&#125;&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>先看第一个问题，为什么要bind，这是JavaScript基础的一个问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*bind,call,apply的用法再不赘述，看两个🌰*/</span></div><div class="line"><span class="comment">// 第一个🌰</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    name: <span class="string">'javascipt'</span>,</div><div class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.name &#125;</div><div class="line">&#125;</div><div class="line">obj.getName() <span class="comment">// 输出了 'javascipt'</span></div><div class="line"><span class="keyword">var</span> fakerGetName = obj.getName;</div><div class="line">fakerGetName() <span class="comment">// undefined 因为this的指向改变了，this是运行时才绑定的。</span></div><div class="line"></div><div class="line"><span class="comment">// 第二个🌰，有时候我们使用Babel转换代码，会看到类似 (0, R.h)('xxx');</span></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> //使用逗号表达式其实就是上面🌰一的情况,为了释放this,其实 0 || R.h 也可以达到同样的目的</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">  再看render函数里面的 表达式onClick=&#123;this.handleClick&#125;实际上就是例子一的情况，就是赋值操作，所以需要bind</span></div><div class="line"><span class="comment">*/</span></div></pre></td></tr></table></figure><p>上面讨论的为什么要bind，接下来看第二个问题，两种bind方式的区别。首先官网已经明确指明推荐使用在constructor函数中绑定的方式，如果使用箭头函数这种方式，每次render的时候函数都会被创建，如果函数里涉及到一个componment的操作，还会造成不必要的渲染，带来了性能问题。</p><h4 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h4><p> 当渲染一个列表时候一定会设置key，key有两个用途，第一在diff过程中性能优化的，第二，和自定义事件系统的标识有关，后面再写key怎么做的diff性能优化，怎么和事件相关，先看一些常规的key操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> List = [</div><div class="line">    &#123;<span class="attr">id</span>: <span class="number">10001</span>, <span class="attr">content</span>: <span class="string">'one'</span>&#125;,</div><div class="line">    &#123;<span class="attr">id</span>: <span class="number">10002</span>, <span class="attr">content</span>: <span class="string">'two'</span>&#125;,</div><div class="line">    &#123;<span class="attr">id</span>: <span class="number">10003</span>, <span class="attr">content</span>: <span class="string">'three'</span>&#125;,</div><div class="line">]</div><div class="line">Class Cart extends React.Componment &#123;</div><div class="line">    render() &#123;</div><div class="line">      <span class="keyword">return</span> (&lt;div&gt;</div><div class="line">               &#123;</div><div class="line">                 List.map((item) =&gt; &#123; </div><div class="line">                  return &lt;div key=&#123;item.id&#125;&gt;&#123;item.content&#125;&lt;/div&gt;</div><div class="line">                 &#125;)</div><div class="line">             &#125;</div><div class="line">              &lt;/div&gt;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> - key和性能优化相关，大错特错就是就使用数组的索引当作key，当我们进行删除或者，增加元素时候，key发生了变化，本身key是应该是唯一稳定的表示，diff时比对的，在生产中每当渲染一个列表，后端返回的数据基本都会有唯一标识的。</span></div><div class="line"><span class="comment"> - 如果我们的key设置相同，仅仅会渲染出一个元素，但是React 16.0.0 渲染出了所有元素，报了一个Warning: Each child in an array or iterator should have a unique 'key' prop.</span></div><div class="line"><span class="comment"> - 如果不设置key同样会报上面</span></div><div class="line"><span class="comment">*/</span></div></pre></td></tr></table></figure><h4 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h4><p>   使用React我们基本不会接触到DOM，因为框架帮你更新视图，但有些情况，我们确实要操作DOM，可以通过refs来获取DOM的引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> 什么时候我们可能会需要使用Refs呢 ？</span></div><div class="line"><span class="comment"> - Managing focus, text selection, or media playback.</span></div><div class="line"><span class="comment"> - 动画</span></div><div class="line"><span class="comment"> - 使用第三方类库</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="comment">// 先明确一点不要过渡使用ref</span></div></pre></td></tr></table></figure><p>使用ref有几种方式 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1 - 最古老的方式 ref="xxx"</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cart</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  componentDidMount ()&#123;</div><div class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>.inputRef)</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;input ref=<span class="string">"inputRef"</span> onChange=&#123;<span class="keyword">this</span>.handleChange&#125;/&gt;</div><div class="line">      &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    )</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line">// 这个古老的方法将被废弃了，有一些坑https://github.com/facebook/react/pull/8333#issuecomment-271648615</div><div class="line"></div><div class="line"><span class="comment">// 2 - Callback Refs，这是一个比较推荐的ref姿势</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cart</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.setInputRef = <span class="function"><span class="params">element</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">this</span>.inputRef = element;      </div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  handleChange() &#123;</div><div class="line">        </div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;input ref=&#123;<span class="keyword">this</span>.setInputRef&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125;/&gt;</div><div class="line">      &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    )</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ 3 - Creating Refs React新增加的API</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">class Cart extends React.Component &#123;</span></div><div class="line"><span class="regexp">  constructor() &#123;</span></div><div class="line"><span class="regexp">   this.inputRef = React.createRef();</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">  handleChange() &#123;</span></div><div class="line"><span class="regexp">    /</span><span class="regexp">/ this.inputRef.current ..  DOM引用</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">  render() &#123;</span></div><div class="line"><span class="regexp">    return (</span></div><div class="line"><span class="regexp">      &lt;div&gt;</span></div><div class="line"><span class="regexp">        &lt;input ref=&#123;this.setInputRef&#125; onChange=&#123;this.handleChange&#125;/</span>&gt;</div><div class="line">      &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    )</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp">/</span>* 引用文档的一段话,</div><div class="line">React will assign the current property <span class="keyword">with</span> the DOM element when the component mounts, and assign it back to <span class="literal">null</span> when it unmounts. ref updates happen before componentDidMount or componentDidUpdate lifecycle hooks.</div><div class="line"></div><div class="line"> 组件挂载后我们可以通过current属性获取DOM的引用，组件卸载的时候ref返回<span class="literal">null</span>，ref更新发生在componentDidMount/componentDidUpdate生命周期的钩子中。</div><div class="line">*<span class="regexp">/</span></div></pre></td></tr></table></figure><p>再讨论一下组件嵌套ref的情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// - Class Component </span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZombieWrapper</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  constuctor(props) &#123;</div><div class="line">   <span class="keyword">super</span>(props);</div><div class="line">   <span class="keyword">this</span>.textInput = React.createRef();</div><div class="line">  &#125;</div><div class="line">  componentDidMount() &#123;</div><div class="line">    <span class="comment">// this.textInput.current  </span></div><div class="line">    <span class="comment">// 这有一个细小的差别实际上，这里获取的是React Element 不是很重要</span></div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (&lt;Cart ref=&#123;this.textInput&#125;/&gt;)      </div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">            </div><div class="line">// function Component，函数组件如何呢？</div><div class="line">function MyStateLessComponent() &#123;</div><div class="line">  return &lt;input/&gt;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ZombieWrapper extends React.Component &#123;</div><div class="line">  constructor(props) &#123;</div><div class="line">    super(props);      </div><div class="line">    this.inputRef = React.createRef();</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;MyStateLessComponent ref=&#123;this.inputRef&#125;/&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    )     </div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">// 这种方式不是不是行的，要改成class component的写法</div></pre></td></tr></table></figure><p>还有给父组件暴露DOM的情况，其实用的真心不多。</p><h4 id="State-vs-Props"><a href="#State-vs-Props" class="headerlink" title="State vs Props"></a>State vs Props</h4><p>React是单向数据流的, props在父子组件之间传递流动，state是组件内部自己管理维护的，类比一下，props更像是函数的参数，state更像函数内部声明的变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">component</span>(<span class="params">prrops, ...opts</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> state = &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> props = &#123;&#125;;</div><div class="line">component(props);  </div><div class="line"><span class="comment">/* </span></div><div class="line"><span class="comment"> 使用函数时会给函数传递参数，函数内部还会声明变量自己内部, 可以类比React的 props，state。</span></div><div class="line"><span class="comment"> 设计组件是要考虑清楚，到底是props还是state呢。这个关系到组件的维护性和扩展性。</span></div><div class="line"><span class="comment"> 其实很类似，我们设计一个工具函数时候，我我们选择传递参数呢，还是在函数内部定义是一个道理。</span></div><div class="line"><span class="comment">*/</span></div></pre></td></tr></table></figure><h4 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h4><p>  setState是最最重要的API，整个视图的更新围绕着这个函数，setState这个API网上有太多文章了，后面我会写写出setState具体的实现，这里，先关注一下setState几种用法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> 明确一点，到现在v16.4.0 setState的实现还是同步，仅仅是表现上有的时候是延迟(defer)！！这种延迟的表现让你觉得setState是"异步"的，至于这种延迟其实本质上是通过流程控制实现的，至于流程控制是基于事务(transaction)做的，通过加锁实现，我们可以控制事物开始的前置行为，后置行为，来控制流程变化，类似中间件的洋葱模型，这就是setState的实现理论，后面我会写出详细的过程。(PS v16.0.0 已经不是通过事务实现的setState，但是了解之前的setState实现也是一件很有cool是事情。)</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="comment">// 言归正传，说回setState的几种写法</span></div><div class="line"></div><div class="line"><span class="comment">// 1 - setState(&#123;&#125;) //这是常见的setState用法</span></div><div class="line"></div><div class="line">setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 2 - setState(&#123;&#125;，function()&#123;&#125;);</span></div><div class="line"><span class="comment">/* callback用法，因为setState大多数时间会被延迟执行，我们有时候想在state真实改变之后做一些事情，注意我说了大多数会被延迟，因为在setState在setTimeout里面表现的时时的改变，我说的很严谨。</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line">setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count); <span class="comment">// count 已经改变</span></div><div class="line">   <span class="comment">// dosomething。。。。</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// 3 - setStaet(() =&gt; &#123;&#125;) 传入函数形式</span></div><div class="line"></div><div class="line">setState((prevState, props) = &gt; &#123; <span class="attr">count</span>: prevState.count + <span class="number">1</span>&#125;);</div></pre></td></tr></table></figure><h4 id="forceUpdate"><a href="#forceUpdate" class="headerlink" title="forceUpdate"></a>forceUpdate</h4><p>通常情况下，组件的state/props改变，组件会re-render，但是如果你的组件依赖其他的数据，需要使用forceUpdate开启强制刷新，他会跳过shouldComponentUpdate这个生命周期钩子，包括子组件，尽量少使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   第一次接触React的时候是还是15年我在天猫实习时候，毕业之后一直写React有2年的时间了，从0.13版本到现在16.4.0一直在跟进，并且投入大量的精力深入学习，对React疯狂热爱，痴迷，自己对setState, Transaction, Diff过程, Vi
      
    
    </summary>
    
    
  </entry>
  
</feed>
